require "懒人综合插件"
local find_str = function(x1, y1, x2, y2, str, color, sim)
	return findStr(x1, y1, x2, y2, str, color, sim)
end

dictIndex = 0
dictName = "s2.txt"
setDict(dictIndex, dictName)
useDict(dictIndex)

function haimo()      --点击挑战boss界面中海魔希特拉

	local x=-1 y=-1
	ret,x,y=find_str(169,184,360,599,"挑战海魔希特拉","B2B3AA-292D3A",0.85)
	if x~=-1 and y ~=-1 then
		tingliu({1200,1400})
		tap_random(x,y,2,300,350)
		return true
	end
end

function tiaozhaoboss()      --点挑战boss文字

	local x=-1 y=-1
	ret,x,y=find_str(984,127,1069,152,"挑战boss","9E8C6D-544F4D",0.55)
	if x~=-1 and y ~=-1 then
		tingliu({1200,1400})
		tap_random(x,y,2,300,350)
		return true
	end
end

function reopen_challenge_boss()
    open_challenge_boss()
    table.insert(stack, "wait_boss")
end


function is_in_fighting_boss()
	useDict(0)
    print("正在判断是否正在打boss")
    tingliu({300, 400})
    local start_time = os.time()
    while (os.time() - start_time) < 40 do -- 设置最大等待时间为 40 秒
        类_图色.刷新屏幕()
        
        local ret, x, y = find_str(83, 237, 171, 270, "伤害第一可", "EB7F00-101010|CF7000-101010|9C5500-101010|BD6701-101010|8C4C00-050505", 0.9)
        -- 判断是否存在 "logo1.png"
        local 设置 = {"logo1.png", 0.8, 522, 14, 578, 70, "101010"}

        if x ~= -1 and y ~= -1 and 类_图色.找图(设置) then
            print("正在打boss")
            if is_character_dead() then
                print("角色已死亡，重新开始")
                tingliu({2000,2500})
                print("重新进入地图")
                open_challenge_boss()
                table.insert(stack, "reopen_challenge_boss")
            else
                tingliu({1000, 1200})
                return true
            end
        end
        tingliu({1000, 1200})
    end
    print("超时，未找到打boss的特征")
    return false
end

function is_finish_boss()
	print("正在判断是否已经打完boss")
	tingliu({200,300})
	类_图色.刷新屏幕()
	local 设置 = {"logo3.png", 0.8, 57, 59, 157, 90, "101010"}
	local times = 0
	local max_wait_time = 13 -- 设置最大等待时间为 2 秒
	local start_time = os.time()
	while (os.time() - start_time) < max_wait_time do
		if 类_图色.找图(设置) then
			print("出现该名称，判断打完boss")
			tingliu({1000, 1200})
			return true
		end
		tingliu({500, 600})
	end
	print("超时，未找到打完Boss的特征")
	return false
end

function open_challenge_boss()
	
	print("执行open_challenge_boss()")
	tingliu({1500,1800})
	tap(26,26,1,300,350)
	tingliu({1000,1200})
	print("开始操作tiaozhaoboss()")
    useDict(dictIndex)
    local found = tiaozhaoboss()
	if not found then --点击挑战Boss
		tingliu({1500,1700})
		tap_random(365, 160,2,300,350)       --弹出挑战boss界面后点秘境boss
	else
		print("开始操作while not tiaozhaoboss()")
		while not tiaozhaoboss() do
			tingliu({1300,1500})
			tap_random(26,26,1,300,350)
			tingliu({200,250})
			tap_random(26,26,1,300,350)
			tingliu({1300,1500})
			tap_random(1026,27,1,300,350)
			tingliu({1300,1500})
			useDict(dictIndex) -- 使用字典索引
			tiaozhaoboss()
			break
		end
		tingliu({1300,1500})
		tap_random(365, 160,2,300,350)  --弹出挑战boss界面后点秘境boss
	end
	tingliu({1500,1800})
	
	local ret, x, y = find_str(955, 144, 1097, 181, "t0|t1|t2|t3|t4|t5", "A87E20-101010|A4A453-101010|DCCC64-101010|B8B69D-101010|E1BF35-101010|B18829-101010|DCBF7A-101010|9B8B6B-101010|896C12-101010|C39E45-404040|EDE198-404040|534223-101010|B9A983-101010|B9A983-101010|9F8F67-505050", 0.86)
	if x ~= -1 and y ~= -1 then
		challenge_left = tonumber(ret)
		print("挑战boss次数为:"..challenge_left)
		if challenge_left > 0 then
			haimo()     --点海魔
			tingliu({1200,1400})
			tap_random(759, 522,3,300,350)     --点中间
			return true
		end
	else
		print("识别不了挑战boss次数字符")
	end
	tingliu({200,300})
	return false
end
function record_start_feature()     ---识别退出挑战地图
	print("执行勇者大陆地图识别")
	setDict(0, "s3.txt")
	useDict(0)
	local x=-1 y=-1
	local ret, x, y = find_str(1076,1,1162,28, "勇者大陆", "9DA0A3-363738", 0.82)
	if x ~= -1 and y ~= -1 then
		print("地图为:"..x,y)
		tingliu({1000,1200})
		return true
	else
		tingliu({1000,1200})
		print("识别不出勇者大陆文字")
		return false
	end
end
function is_character_dead() ---如果角色死亡点击复活
	print("执行判断角色是否死亡")
	tingliu({1000,1200})
	local ret, x, y = find_str(691, 426, 784, 453, "原地复活", "C7C9CA-101010|B8B3AD-101010|BAA89A-101010|D3D7DB-101010|A09790-050505", 0.9)
	if x ~= -1 and y ~= -1 then
		print("角色死亡点击："..ret)
		tap_random(540, 437,2,300,340)
		tingliu({2000,2300})
		tap_random(26, 25,1,300,350)
		tingliu({2000,2300})
		tap_random(26, 25,1,300,350)
		tingliu({2000,2300})
		return true
	else
		print("角色未死亡")
		return false
	end
end

function wait_boss()
	if is_in_fighting_boss() then
		table.insert(stack, "fighting_boss")
	else
		print("未能确定正在打boss，继续等待")
		tingliu({1000, 1200})
	end
end

-- 正在打 BOSS
function fighting_boss()
	local fighting_time = os.time() -- 记录开始等待的时间
	while (os.time() - fighting_time) < 40 do -- 最多等待 10 秒
		if is_in_fighting_boss() then
			if is_finish_boss() then
				table.insert(stack, "finish_boss")
				break
			else
				-- 继续等待
				print("正在打boss中")
				tingliu({1000, 1200})
			end
		else
			print("未能确定正在打boss，继续等待")
			tingliu({1000, 1200})
		end
	end
	if (os.time() - fighting_time) >= 40 then
		print("等待超时")
		table.insert(stack, "wait_boss")
	end
end

-- BOSS 打完
function finish_boss()
	is_finish_boss()
	-- 打完boss后等待 boss 再次出现
	table.insert(stack, "wait_boss")
end

-- 角色死亡
--[===[function Emergency_boss()
	if is_character_dead() then
		print("角色已死亡，重新进入挑战地图")
		open_challenge_boss() -- 重新进入挑战地图
        table.insert(stack, "reopen_challenge_boss")
	else
		table.insert(stack, "Emergency_boss")
	end
end]===]

-- 判断是否挑战完毕
function Exit_Challenge_Boss()
	if record_start_feature() then
		print("挑战结束")
	else
		table.insert(stack, "Exit_Challenge_Boss")
	end
end

-- 主循环
open_challenge_boss()
while #stack > 0 do
    local state = stack[#stack]
    print("当前状态：", state)
    if state == "open_challenge_boss" then
        open_challenge_boss()
    elseif state == "wait_boss" then
        wait_boss()
    elseif state == "fighting_boss" then
        fighting_boss()
    elseif state == "finish_boss" then
        finish_boss()
    elseif state == "reopen_challenge_boss" then
        reopen_challenge_boss()
    elseif state == "Exit_Challenge_Boss" then
        Exit_Challenge_Boss()
    else
        print("未知状态："..state)
        break
    end
    sleep(2000)
    table.remove(stack)
end



